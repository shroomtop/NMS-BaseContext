<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NMS Galactic Lab [Architect Edition â€“ Minimal]</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Three.js (non-module, CDN) -->
  <script src="https://unpkg.com/three@0.148.0/build/three.min.js"></script>

  <style>
    /* Basic Reset */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #1f1f23;
      background-image:
        radial-gradient(circle at 0 0, rgba(255,255,255,0.04) 0, transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(255,255,255,0.04) 0, transparent 55%);
      color: #f5f5f5;
      display: flex;
    }

    /* Glassmorphism Panel Base */
    .glass {
      background: rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
    }

    /* Scrollbar styling */
    .scroll-thin::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    .scroll-thin::-webkit-scrollbar-thumb {
      background: rgba(200, 200, 200, 0.4);
      border-radius: 999px;
    }
    .scroll-thin::-webkit-scrollbar-track {
      background: transparent;
    }

    /* App Layout */
    #app-container {
      display: flex;
      width: 100%;
      height: 100%;
      padding: 10px;
      gap: 10px;
    }

    .sidebar {
      width: 260px;
      height: 100%;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: hidden;
    }

    #center-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 0;
    }

    /* Left Panel */
    #header-block {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }

    #header-title {
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #a5b4fc;
    }

    #header-sub {
      margin-top: 2px;
      font-size: 11px;
      color: #9ca3af;
    }

    #file-controls {
      display: flex;
      gap: 6px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }

    .btn, .btn-label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(15,15,20,0.85);
      color: #e5e7eb;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.05s ease;
      white-space: nowrap;
    }

    .btn:hover,
    .btn-label:hover {
      background: rgba(35,35,45,0.95);
      border-color: rgba(255,255,255,0.35);
    }

    .btn:active,
    .btn-label:active {
      transform: scale(0.97);
    }

    .btn-primary {
      background: #22c55e;
      border-color: #16a34a;
      color: #022c22;
      font-weight: 600;
    }

    .btn-primary:hover {
      background: #4ade80;
      border-color: #16a34a;
    }

    #fileInput {
      display: none;
    }

    #context-block {
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      font-size: 11px;
    }

    #ctx-label-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    #ctx-label-row span:first-child {
      color: #9ca3af;
      font-weight: 600;
      letter-spacing: 0.06em;
      font-size: 10px;
    }

    #ctx-status {
      font-weight: 600;
      font-size: 10px;
    }

    #ctx-details {
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      color: #9ca3af;
      word-break: break-all;
      margin-bottom: 6px;
    }

    #btnInjectContext {
      width: 100%;
      font-size: 11px;
    }

    #btnInjectContext:disabled {
      opacity: 0.35;
      cursor: not-allowed;
    }

    #base-list-label {
      margin-top: 4px;
      margin-bottom: 4px;
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.08em;
      color: #9ca3af;
    }

    #baseList {
      flex: 1;
      overflow-y: auto;
      padding-right: 2px;
      font-size: 11px;
    }

    .base-group {
      border-radius: 7px;
      border: 1px solid rgba(148,163,184,0.24);
      margin-bottom: 6px;
      overflow: hidden;
      background: rgba(15,23,42,0.45);
    }

    .base-group-header {
      padding: 4px 7px;
      font-size: 10px;
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: #6b7280;
      background: rgba(15,23,42,0.8);
      border-bottom: 1px solid rgba(148,163,184,0.24);
    }

    .base-item-btn {
      width: 100%;
      text-align: left;
      padding: 5px 8px;
      border: none;
      background: transparent;
      color: #d1d5db;
      cursor: pointer;
      font-size: 11px;
      border-left: 2px solid transparent;
      transition: background 0.12s ease, border-color 0.12s ease, color 0.12s ease;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .base-item-btn:hover {
      background: rgba(30,64,175,0.25);
    }

    .base-item-btn.active {
      background: rgba(37,99,235,0.25);
      color: #e5e7eb;
      border-color: #60a5fa;
    }

    /* Center Panel */
    #toolbar {
      height: 38px;
      padding: 6px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    #toolbar-title {
      font-size: 11px;
      color: #9ca3af;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    #toolbar-controls {
      display: flex;
      gap: 6px;
    }

    #canvas-area {
      flex: 1;
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      background-color: #202329;
      background-image: radial-gradient(circle, rgba(255,255,255,0.05) 1px, transparent 1px);
      background-size: 26px 26px;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Right Panel */
    #selection-block {
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      font-size: 11px;
    }

    #selection-title {
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin-bottom: 4px;
    }

    #selection-info,
    #no-selection {
      margin-top: 4px;
    }

    #no-selection {
      color: #6b7280;
      font-size: 11px;
    }

    .field-group {
      margin-bottom: 6px;
    }

    .field-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin-bottom: 2px;
    }

    .mono-input {
      width: 100%;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid rgba(148,163,184,0.45);
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
      font-size: 11px;
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .mono-input[readonly] {
      opacity: 0.7;
    }

    #xyz-grid {
      display: grid;
      grid-template-columns: 20px 1fr 40px 40px;
      gap: 4px;
      align-items: center;
      margin-top: 4px;
    }

    .axis-label {
      font-weight: 700;
      font-size: 11px;
      text-align: center;
    }

    .axis-label.x { color: #f97373; }
    .axis-label.y { color: #4ade80; }
    .axis-label.z { color: #60a5fa; }

    .btn-small {
      font-size: 10px;
      padding: 3px 4px;
    }

    #storage-box {
      margin-top: 6px;
      padding: 4px 6px;
      border-radius: 6px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.4);
      font-size: 10px;
    }

    #storage-label {
      color: #9ca3af;
      margin-bottom: 2px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 9px;
    }

    #storage-format {
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: #e5e7eb;
      font-size: 11px;
    }

    /* Global Offset Block */
    #offset-block {
      padding-top: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      font-size: 11px;
    }

    #offset-title {
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.08em;
      color: #fca5a5;
      margin-bottom: 4px;
    }

    #offset-desc {
      font-size: 10px;
      color: #9ca3af;
      margin-bottom: 6px;
    }

    #offset-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 4px;
      margin-bottom: 6px;
    }

    #btnOffsetBase {
      width: 100%;
      font-size: 11px;
      background: #ef4444;
      border-color: #b91c1c;
      color: #f9fafb;
      font-weight: 600;
    }

    #btnOffsetBase:hover {
      background: #f97373;
    }

    /* Debugger Block */
    #debug-block {
      padding-top: 8px;
      font-size: 10px;
    }

    #debug-title {
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin-bottom: 4px;
    }

    .debug-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px;
    }

    .debug-label {
      color: #9ca3af;
    }

    .debug-value {
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: #e5e7eb;
    }

    /* Small screen fallback: stack panels */
    @media (max-width: 960px) {
      #app-container {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        height: auto;
        min-height: 150px;
      }
      #center-panel {
        height: 50vh;
      }
    }
  </style>
</head>
<body>
  <div id="app-container">
    <!-- LEFT PANEL -->
    <div class="sidebar glass" id="left-panel">
      <div id="header-block">
        <div id="header-title">NMS GALACTIC LAB</div>
        <div id="header-sub">Architect Edition Â· Single-File Tool</div>
      </div>

      <div id="file-controls">
        <label class="btn-label" for="fileInput">ðŸ“‚ Load JSON</label>
        <input type="file" id="fileInput" accept=".json,.txt" />
        <button id="btnExport" class="btn btn-primary" style="display:none;">ðŸ’¾ Save JSON</button>
      </div>

      <div id="context-block">
        <div id="ctx-label-row">
          <span>CONTEXT (PLAYER)</span>
          <span id="ctx-status">MISSING</span>
        </div>
        <div id="ctx-details">Load BaseContext.json to capture UniverseAddress.</div>
        <button id="btnInjectContext" class="btn" disabled>â¤µ Inject Context to Base</button>
      </div>

      <div id="base-list-label">BASES</div>
      <div id="baseList" class="scroll-thin">
        <div style="font-size:11px;color:#9ca3af;margin-top:4px;">
          Load a save file containing PersistentPlayerBases to begin.
        </div>
      </div>
    </div>

    <!-- CENTER PANEL -->
    <div id="center-panel">
      <div id="toolbar" class="glass">
        <div id="toolbar-title">3D COORDINATE LAB</div>
        <div id="toolbar-controls">
          <button id="btnFrameAll" class="btn btn-small">Center Base</button>
        </div>
      </div>
      <div id="canvas-area" class="glass">
        <div id="canvas-container"></div>
      </div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="sidebar glass" id="right-panel">
      <div id="selection-block">
        <div id="selection-title">OBJECT EDITOR</div>

        <div id="selection-info" style="display:none;">
          <div class="field-group">
            <div class="field-label">Object ID</div>
            <input id="inpObjId" class="mono-input" type="text" readonly />
          </div>

          <div class="field-group">
            <div class="field-label">Local Position (Base Space)</div>
            <div id="xyz-grid">
              <div class="axis-label x">X</div>
              <input id="inpX" class="mono-input" type="number" step="any" />
              <button class="btn btn-small btn-nudge" data-axis="x" data-val="1">+1</button>
              <button class="btn btn-small btn-nudge" data-axis="x" data-val="-1">-1</button>

              <div class="axis-label y">Y</div>
              <input id="inpY" class="mono-input" type="number" step="any" />
              <button class="btn btn-small btn-nudge" data-axis="y" data-val="1">+1</button>
              <button class="btn btn-small btn-nudge" data-axis="y" data-val="-1">-1</button>

              <div class="axis-label z">Z</div>
              <input id="inpZ" class="mono-input" type="number" step="any" />
              <button class="btn btn-small btn-nudge" data-axis="z" data-val="1">+1</button>
              <button class="btn btn-small btn-nudge" data-axis="z" data-val="-1">-1</button>
            </div>
          </div>

          <button id="btnApply" class="btn btn-small" style="width:100%;margin-top:4px;">Apply XYZ to Part</button>

          <div id="storage-box">
            <div id="storage-label">STORAGE FORMAT</div>
            <div id="storage-format">Unknown</div>
          </div>
        </div>

        <div id="no-selection">
          No part selected.<br/>
          <span style="font-size:10px;">Click a cube in the 3D view to edit.</span>
        </div>
      </div>

      <div id="offset-block">
        <div id="offset-title">GLOBAL BASE OFFSET</div>
        <div id="offset-desc">
          Offsets <b>all parts</b> of the active base in local space.<br/>
          Does <b>not</b> move planets or stations.
        </div>
        <div id="offset-grid">
          <input id="offX" class="mono-input" type="number" step="any" placeholder="Î”X" />
          <input id="offY" class="mono-input" type="number" step="any" placeholder="Î”Y" />
          <input id="offZ" class="mono-input" type="number" step="any" placeholder="Î”Z" />
        </div>
        <button id="btnOffsetBase" class="btn">Apply Offset to Entire Base</button>
      </div>

      <div id="debug-block">
        <div id="debug-title">ADDRESS DECODER (EXPERIMENTAL)</div>
        <div class="debug-row">
          <span class="debug-label">HEX</span>
          <span id="dbg-hex" class="debug-value">-</span>
        </div>
        <div class="debug-row">
          <span class="debug-label">SYS</span>
          <span id="dbg-sys" class="debug-value">-</span>
        </div>
        <div class="debug-row">
          <span class="debug-label">PLT</span>
          <span id="dbg-plt" class="debug-value">-</span>
        </div>
        <div class="debug-row">
          <span class="debug-label">VOX</span>
          <span id="dbg-vox" class="debug-value">-</span>
        </div>
      </div>
    </div>
  </div>

<script>
/* ================================================================
   NMS GALACTIC LAB â€“ MINIMAL EDITION
   - Multi-file aware: BaseContext + PersistentPlayerBases
   - Decimal-safe GalacticAddress handling
   - 3D object editor + global base offset
   - Explicitly experimental galactic unpacking
   ================================================================ */

const state = {
  rawJson: null,
  filename: "nms_save.json",
  rootType: null, // 'wrapper', 'baseList', 'singleBase'

  bases: [],
  activeBaseIndex: -1,

  context: {
    available: false,
    hexAddress: null,
    decAddress: null,
    sourceName: null
  },

  scene: null,
  camera: null,
  renderer: null,
  raycaster: new THREE.Raycaster(),
  pointer: new THREE.Vector2(),
  meshes: [],
  selectedMesh: null,

  helpers: {
    matNormal: new THREE.MeshLambertMaterial({ color: 0xaaaaaa }),
    matSelected: new THREE.MeshLambertMaterial({ color: 0xff00ff, emissive: 0x330033 }),
    geomBox: new THREE.BoxGeometry(1, 1, 1)
  },

  controls: {
    frameCurrentBase: () => {}
  }
};

/* ---------------- ADDRESS CODEC ---------------- */

const AddressCodec = {
  toHexFromAny(addr) {
    if (addr == null) return "0x0";

    if (typeof addr === "object") {
      if ("VoxelX" in addr || "VoxelY" in addr || "VoxelZ" in addr) {
        return AddressCodec.packVoxel(addr);
      }
      return "0x0";
    }

    if (typeof addr === "number") {
      try {
        return "0x" + BigInt(addr).toString(16).toUpperCase();
      } catch {
        return "0x0";
      }
    }

    if (typeof addr === "string") {
      const trimmed = addr.trim();
      if (!trimmed) return "0x0";

      if (trimmed.startsWith("0x") || /[a-fA-F]/.test(trimmed)) {
        return trimmed.startsWith("0x")
          ? trimmed.toUpperCase()
          : "0x" + trimmed.toUpperCase();
      }

      try {
        const val = BigInt(trimmed);
        return "0x" + val.toString(16).toUpperCase();
      } catch {
        return "0x0";
      }
    }

    return "0x0";
  },

  packVoxel(ua) {
    try {
      const toUnsigned = (val, bits) => {
        if (val >= 0) return val;
        return (1 << bits) + val;
      };

      const x = toUnsigned(ua.VoxelX || 0, 12) & 0xFFF;
      const z = toUnsigned(ua.VoxelZ || 0, 12) & 0xFFF;
      const y = toUnsigned(ua.VoxelY || 0, 8) & 0xFF;
      const ss = (ua.SolarSystemIndex || 0) & 0xFFF;
      const p  = (ua.PlanetIndex || 0) & 0xF;
      const g  = 0;

      let val = 0n;
      val |= BigInt(x);
      val |= BigInt(z)  << 12n;
      val |= BigInt(y)  << 24n;
      val |= BigInt(g)  << 32n;
      val |= BigInt(ss) << 40n;
      val |= BigInt(p)  << 52n;

      return "0x" + val.toString(16).toUpperCase();
    } catch {
      return "0x0";
    }
  },

  unpackVoxel(hexStr) {
    try {
      const clean = hexStr.replace(/^0x/i, "");
      const val = BigInt("0x" + clean);

      const xU = Number(val & 0xFFFn);
      const zU = Number((val >> 12n) & 0xFFFn);
      const yU = Number((val >> 24n) & 0xFFn);
      const ss = Number((val >> 40n) & 0xFFFn);
      const p  = Number((val >> 52n) & 0xFn);

      const fromUnsigned = (u, bits) => {
        const mid = 1 << (bits - 1);
        return u >= mid ? u - (1 << bits) : u;
      };

      return {
        VoxelX: fromUnsigned(xU, 12),
        VoxelY: fromUnsigned(yU, 8),
        VoxelZ: fromUnsigned(zU, 12),
        SolarSystemIndex: ss,
        PlanetIndex: p
      };
    } catch {
      return { VxelX: 0, VoxelY: 0, VoxelZ: 0, SolarSystemIndex: 0, PlanetIndex: 0 };
    }
  }
};

/* ---------------- UI UPDATE ---------------- */

function updateUI() {
  const list = document.getElementById("baseList");
  list.innerHTML = "";

  const groups = {};
  state.bases.forEach((base, idx) => {
    const hex = AddressCodec.toHexFromAny(base.GalacticAddress);
    const key = hex.length > 8 ? hex.slice(0, 8) : "0x0";
    if (!groups[key]) groups[key] = [];
    groups[key].push({ idx, base, hex });
  });

  const hasBases = Object.keys(groups).length > 0;

  Object.keys(groups).forEach(key => {
    const group = document.createElement("div");
    group.className = "base-group";

    const header = document.createElement("div");
    header.className = "base-group-header";
    header.textContent = "SYS " + key + "...";
    group.appendChild(header);

    groups[key].forEach(item => {
      const btn = document.createElement("button");
      btn.className = "base-item-btn" + (item.idx === state.activeBaseIndex ? " active" : "");
      btn.textContent = item.base.Name || ("Base #" + (item.idx + 1));
      btn.onclick = () => selectBase(item.idx);
      group.appendChild(btn);
    });

    list.appendChild(group);
  });

  if (!hasBases && state.rootType) {
    const msg = document.createElement("div");
    msg.style.fontSize = "11px";
    msg.style.color = "#f97373";
    msg.style.marginTop = "4px";
    msg.textContent = "No bases found in this file.";
    list.appendChild(msg);
  } else if (!state.rootType && !hasBases) {
    const msg = document.createElement("div");
    msg.style.fontSize = "11px";
    msg.style.color = "#9ca3af";
    msg.style.marginTop = "4px";
    msg.textContent = "Load a base file to see bases.";
    list.appendChild(msg);
  }

  const btnInj = document.getElementById("btnInjectContext");
  const txtCtx = document.getElementById("ctx-status");
  const txtDet = document.getElementById("ctx-details");

  if (state.context.available) {
    txtCtx.textContent = "READY";
    txtCtx.style.color = "#4ade80";
    txtDet.textContent = `${state.context.decAddress} (${state.context.hexAddress})`;
    btnInj.disabled = (state.activeBaseIndex === -1);
  } else {
    txtCtx.textContent = "MISSING";
    txtCtx.style.color = "#9ca3af";
    txtDet.textContent = "Load BaseContext.json with UniverseAddress.";
    btnInj.disabled = true;
  }

  const btnEx = document.getElementById("btnExport");
  if (state.rawJson) {
    btnEx.style.display = "inline-flex";
  } else {
    btnEx.style.display = "none";
  }
}

/* ---------------- DEBUGGER ---------------- */

function updateDebugger(hex) {
  const d = AddressCodec.unpackVoxel(hex);
  document.getElementById("dbg-hex").textContent = hex;
  document.getElementById("dbg-sys").textContent = "SS: " + d.SolarSystemIndex;
  document.getElementById("dbg-plt").textContent = "IDX: " + d.PlanetIndex;
  document.getElementById("dbg-vox").textContent = `${d.VoxelX}, ${d.VoxelY}, ${d.VoxelZ}`;
}

/* ---------------- THREE SETUP ---------------- */

function initThree() {
  const container = document.getElementById("canvas-container");
  const w = container.clientWidth;
  const h = container.clientHeight;

  state.scene = new THREE.Scene();

  const grid = new THREE.GridHelper(400, 80, 0x334155, 0x1e293b);
  grid.position.y = -0.5;
  state.scene.add(grid);

  const amb = new THREE.AmbientLight(0xffffff, 0.5);
  state.scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(20, 40, 20);
  state.scene.add(dir);

  state.camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 200000);
  state.camera.position.set(40, 40, 40);
  state.camera.lookAt(0, 0, 0);

  state.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  state.renderer.setSize(w, h);
  container.appendChild(state.renderer.domElement);

  let isDragging = false;
  let prevPos = { x: 0, y: 0 };
  let camRadius = 60;
  let camTheta = Math.PI / 4;
  let camPhi = Math.PI / 4;
  let camCenter = new THREE.Vector3(0, 0, 0);

  const updateCam = () => {
    const y = camRadius * Math.sin(camPhi);
    const rXZ = camRadius * Math.cos(camPhi);
    const x = rXZ * Math.sin(camTheta);
    const z = rXZ * Math.cos(camTheta);
    state.camera.position.set(x + camCenter.x, y + camCenter.y, z + camCenter.z);
    state.camera.lookAt(camCenter);
  };
  updateCam();

  const canvas = state.renderer.domElement;

  canvas.addEventListener("mousedown", e => {
    if (e.button === 2) {
      isDragging = true;
      prevPos = { x: e.clientX, y: e.clientY };
    }
  });

  window.addEventListener("mouseup", () => {
    isDragging = false;
  });

  canvas.addEventListener("contextmenu", e => e.preventDefault());

  canvas.addEventListener("mousemove", e => {
    if (isDragging) {
      const dx = e.clientX - prevPos.x;
      const dy = e.clientY - prevPos.y;
      camTheta -= dx * 0.01;
      camPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camPhi + dy * 0.01));
      prevPos = { x: e.clientX, y: e.clientY };
      updateCam();
    }
  });

  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    camRadius *= 1 + e.deltaY * 0.001;
    camRadius = Math.max(2, Math.min(200000, camRadius));
    updateCam();
  }, { passive: false });

  canvas.addEventListener("click", e => {
    if (isDragging) return;
    const rect = canvas.getBoundingClientRect();
    state.pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    state.pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    state.raycaster.setFromCamera(state.pointer, state.camera);
    const hits = state.raycaster.intersectObjects(state.meshes.map(m => m.mesh));

    if (hits.length > 0) {
      const mesh = hits[0].object;
      const wrap = state.meshes.find(m => m.mesh === mesh);
      selectObject(wrap);
    } else {
      selectObject(null);
    }
  });

  state.controls.frameCurrentBase = () => {
    if (!state.meshes.length) {
      camCenter.set(0, 0, 0);
      camRadius = 40;
      updateCam();
      return;
    }
    const box = new THREE.Box3();
    state.meshes.forEach(m => box.expandByPoint(m.mesh.position));
    const size = new THREE.Vector3();
    box.getSize(size);
    const center = new THREE.Vector3();
    box.getCenter(center);

    camCenter.copy(center);
    const maxDim = Math.max(size.x, size.y, size.z, 10);
    camRadius = maxDim * 1.8;
    camPhi = Math.PI / 4;
    camTheta = Math.PI / 4;
    updateCam();
  };

  window.addEventListener("resize", () => {
    const w2 = container.clientWidth;
    const h2 = container.clientHeight;
    state.camera.aspect = w2 / h2;
    state.camera.updateProjectionMatrix();
    state.renderer.setSize(w2, h2);
  });

  const animate = () => {
    requestAnimationFrame(animate);
    state.renderer.render(state.scene, state.camera);
  };
  animate();
}

/* ---------------- FILE LOADING ---------------- */

function loadFile(file) {
  const reader = new FileReader();
  reader.onload = e => {
    const text = e.target.result;
    let json;
    try {
      json = JSON.parse(text);
    } catch (err) {
      console.error(err);
      alert("Failed to parse JSON. Check console.");
      return;
    }

    const isWrapper =
      json &&
      json.PlayerStateData &&
      Array.isArray(json.PlayerStateData.PersistentPlayerBases);
    const hasUniverseAddress =
      json &&
      json.PlayerStateData &&
      json.PlayerStateData.UniverseAddress &&
      json.PlayerStateData.UniverseAddress.GalacticAddress != null;
    const isBaseList = Array.isArray(json);
    const isSingleBase = json && json.Objects && json.GalacticAddress != null;

    // Context-only BaseContext
    if (!isWrapper && hasUniverseAddress && !isBaseList && !isSingleBase) {
      const ua = json.PlayerStateData.UniverseAddress;
      const rawGA = ua.GalacticAddress;
      state.context.decAddress = String(rawGA);
      state.context.hexAddress = AddressCodec.toHexFromAny(rawGA);
      state.context.sourceName = file.name;
      state.context.available = true;
      updateUI();
      alert("Context loaded. Now load PersistentPlayerBases.json or a wrapper save to edit bases.");
      return;
    }

    // Wrapper with bases + context
    if (isWrapper) {
      state.rawJson = json;
      state.filename = file.name;
      state.rootType = "wrapper";
      state.bases = json.PlayerStateData.PersistentPlayerBases || [];

      if (hasUniverseAddress) {
        const ua = json.PlayerStateData.UniverseAddress;
        const rawGA = ua.GalacticAddress;
        state.context.decAddress = String(rawGA);
        state.context.hexAddress = AddressCodec.toHexFromAny(rawGA);
        state.context.sourceName = file.name + " (wrapper)";
        state.context.available = true;
      }

      updateUI();
      if (state.bases.length > 0) selectBase(0);
      return;
    }

    // Raw PersistentPlayerBases array
    if (isBaseList) {
      state.rawJson = json;
      state.filename = file.name;
      state.rootType = "baseList";
      state.bases = json;
      updateUI();
      if (state.bases.length > 0) selectBase(0);
      return;
    }

    // Single base
    if (isSingleBase) {
      state.rawJson = json;
      state.filename = file.name;
      state.rootType = "singleBase";
      state.bases = [json];
      updateUI();
      selectBase(0);
      return;
    }

    alert("Unknown file shape. No bases or UniverseAddress detected.");
  };
  reader.readAsText(file);
}

/* ---------------- BASE & OBJECT SELECTION ---------------- */

function selectBase(idx) {
  state.activeBaseIndex = idx;
  updateUI();

  const base = state.bases[idx];
  if (!base) return;

  const hex = AddressCodec.toHexFromAny(base.GalacticAddress);
  updateDebugger(hex);

  state.meshes.forEach(wrap => state.scene.remove(wrap.mesh));
  state.meshes = [];

  if (base.Objects && Array.isArray(base.Objects)) {
    base.Objects.forEach(obj => {
      let x = 0, y = 0, z = 0;
      let format = "unknown";

      if (Array.isArray(obj.Position)) {
        x = obj.Position[0];
        y = obj.Position[1];
        z = obj.Position[2];
        format = "array";
      } else if (obj.Position && typeof obj.Position === "object") {
        x = obj.Position.x;
        y = obj.Position.y;
        z = obj.Position.z;
        format = "object";
      }

      const mesh = new THREE.Mesh(state.helpers.geomBox, state.helpers.matNormal);
      mesh.position.set(x, y, z);
      state.scene.add(mesh);

      state.meshes.push({ mesh, data: obj, posFormat: format });
    });
  }

  state.controls.frameCurrentBase();
  selectObject(null);
}

function selectObject(wrapper) {
  if (state.selectedMesh) {
    state.selectedMesh.mesh.material = state.helpers.matNormal;
  }

  state.selectedMesh = wrapper;

  const info = document.getElementById("selection-info");
  const none = document.getElementById("no-selection");

  if (wrapper) {
    wrapper.mesh.material = state.helpers.matSelected;
    info.style.display = "";
    none.style.display = "none";

    document.getElementById("inpObjId").value =
      wrapper.data.ObjectID || wrapper.data.ID || "Unknown";
    document.getElementById("inpX").value = wrapper.mesh.position.x;
    document.getElementById("inpY").value = wrapper.mesh.position.y;
    document.getElementById("inpZ").value = wrapper.mesh.position.z;
    document.getElementById("storage-format").textContent = wrapper.posFormat.toUpperCase();
  } else {
    info.style.display = "none";
    none.style.display = "";
  }
}

/* ---------------- EDITING: SINGLE OBJECT ---------------- */

function applyChanges() {
  if (!state.selectedMesh) return;

  const x = parseFloat(document.getElementById("inpX").value);
  const y = parseFloat(document.getElementById("inpY").value);
  const z = parseFloat(document.getElementById("inpZ").value);
  if (isNaN(x) || isNaN(y) || isNaN(z)) return;

  const wrap = state.selectedMesh;
  wrap.mesh.position.set(x, y, z);

  if (wrap.posFormat === "array") {
    wrap.data.Position[0] = x;
    wrap.data.Position[1] = y;
    wrap.data.Position[2] = z;
  } else if (wrap.posFormat === "object") {
    wrap.data.Position.x = x;
    wrap.data.Position.y = y;
    wrap.data.Position.z = z;
  }
}

/* ---------------- EDITING: GLOBAL OFFSET ---------------- */

function applyGlobalOffset() {
  if (state.activeBaseIndex === -1) return;
  const base = state.bases[state.activeBaseIndex];
  if (!base || !Array.isArray(base.Objects)) return;

  const dx = parseFloat(document.getElementById("offX").value) || 0;
  const dy = parseFloat(document.getElementById("offY").value) || 0;
  const dz = parseFloat(document.getElementById("offZ").value) || 0;

  if (dx === 0 && dy === 0 && dz === 0) return;

  const msg =
    "This will offset EVERY part in this base by:\n" +
    `Î”X: ${dx}, Î”Y: ${dy}, Î”Z: ${dz}\n\n` +
    "This only affects local base coordinates â€” not planet position.\n\nContinue?";
  if (!confirm(msg)) return;

  base.Objects.forEach(obj => {
    if (Array.isArray(obj.Position)) {
      obj.Position[0] += dx;
      obj.Position[1] += dy;
      obj.Position[2] += dz;
    } else if (obj.Position && typeof obj.Position === "object") {
      obj.Position.x += dx;
      obj.Position.y += dy;
      obj.Position.z += dz;
    }
  });

  state.meshes.forEach(wrap => {
    wrap.mesh.position.x += dx;
    wrap.mesh.position.y += dy;
    wrap.mesh.position.z += dz;
  });

  state.controls.frameCurrentBase();
  alert("Global offset applied to base.");
}

/* ---------------- CONTEXT INJECTION ---------------- */

function injectContext() {
  if (!state.context.available || state.activeBaseIndex === -1) return;
  const base = state.bases[state.activeBaseIndex];
  if (!base) return;

  const oldAddr = String(base.GalacticAddress || "None");
  const newAddr = state.context.decAddress;

  const msg =
    `Base "${base.Name || ("#" + (state.activeBaseIndex + 1))}"\n\n` +
    `OLD GalacticAddress: ${oldAddr}\n` +
    `NEW GalacticAddress: ${newAddr}\n\n` +
    "This effectively moves the base to the context system.\n\nProceed?";
  if (!confirm(msg)) return;

  base.GalacticAddress = newAddr;

  updateUI();
  selectBase(state.activeBaseIndex);
  alert("Context injected into base GalacticAddress.");
}

/* ---------------- EXPORT ---------------- */

function exportJson() {
  if (!state.rawJson) return;
  const str = JSON.stringify(state.rawJson, null, 2);
  const blob = new Blob([str], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "edited_" + state.filename;
  a.click();
}

/* ---------------- BOOTSTRAP ---------------- */

window.addEventListener("DOMContentLoaded", () => {
  initThree();
  updateUI();

  document.getElementById("fileInput").addEventListener("change", e => {
    if (e.target.files[0]) loadFile(e.target.files[0]);
  });

  document.getElementById("btnApply").addEventListener("click", applyChanges);

  document.querySelectorAll(".btn-nudge").forEach(btn => {
    btn.addEventListener("click", () => {
      if (!state.selectedMesh) return;
      const axis = btn.dataset.axis;
      const val = parseFloat(btn.dataset.val);
      const id = axis === "x" ? "inpX" : axis === "y" ? "inpY" : "inpZ";
      const input = document.getElementById(id);
      input.value = parseFloat(input.value || "0") + val;
      applyChanges();
    });
  });

  document.getElementById("btnInjectContext").addEventListener("click", injectContext);
  document.getElementById("btnExport").addEventListener("click", exportJson);
  document.getElementById("btnFrameAll").addEventListener("click", () => {
    state.controls.frameCurrentBase();
  });
  document.getElementById("btnOffsetBase").addEventListener("click", applyGlobalOffset);
});
</script>
</body>
  </html>
